#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
NICG input generator: 1D A/B domains + per-nucleosome epigenetic states + linker lengths.

This script produces inputs for `chromatin_builder.py` (NICG chromatin builder)

Key outputs (written to --outdir):
  1) chains.txt
     Top-level multi-chain list: contains one line "chain input_chain1.txt".

  2) input_chain1.txt
     The chain definition file expected by chromatin_builder.py, containing:
       nuc N
       ll  l0 l1 ... lN     (N+1 integers; linker lengths in *linker-DNA beads*)
       H1  0/1 ...          (length N)
       ac  0/1 ...          (length N)
       brd4 0/1 ...         (length N)
       cg <path>            (optional; passed through)

  3) nucs.bed
     Per nucleosome record:
       chrom start end comp ac brd4 H1

  4) settings.used.json
     Parameters used + derived statistics for reproducibility and sanity checking.

--------------------------------------------------------------------------------
MODEL SUMMARY (matches your spec by default)

A/B domains:
  - Domain lengths are exponential.
  - Two separate means: mean(A) and mean(B) (defaults both 12.5 kb).
  - Domains are generated by alternation (A,B,A,B,...) starting from a random type
    unless you set `start_compartment`.

  Note:
    If mean(A)==mean(B), the expected bp fraction is 50/50 for long chains, but
    not enforced exactly. If you later set different means, the expected bp fraction
    becomes mean(A)/(mean(A)+mean(B)) under alternating generation.

Epigenetics:
  - Acetylation:
      * p(ac=1 | B)
      * p(ac=1 | A)

  - BRD4:
      * p(brd4=1 | ac=1) = brd4_given_ac
      * brd4=0 if ac=0

  - Linker histone H1:
      * p(H1=1 | A)
      * p(H1=1 | B)

Linkers:
  - Internal linker lengths (between nucleosomes) are sampled as a truncated normal in bp:
      mean = linker_bp_mean (default 40 bp)
      sd   = linker_bp_sd   (default 21 bp)
    Negative values are rejected.
  - Leading overhang bp is user-set (default 0).
  - Trailing overhang bp is chosen to make total length exact.

Conversion to builder format:
  - chromatin_builder expects linker lengths in *coarse-grained linker-DNA beads*.
  - We convert bp -> beads by round(bp / bp_per_bead) (default 10.5 bp/bead).

--------------------------------------------------------------------------------
"""

from __future__ import annotations

import argparse
import json
import math
import os
from dataclasses import dataclass, asdict
from typing import Dict, List, Optional, Tuple

import numpy as np


# ---------------------------
# Settings / configuration
# ---------------------------

@dataclass
class Settings:
    # Total 1D fiber length
    total_kb: float = 1000.0

    # Name used in BED/bedGraph outputs
    chrom_name: str = "chrSim"

    # NICG geometry in bp
    nucleosomal_dna_bp: int = 147          # bp wrapped on nucleosome
    bp_per_bead: float = 10.5              # 10.5 bp per coarse-grained DNA bead

    # Linker distribution (in bp), truncated normal
    linker_bp_mean: float = 40.0
    linker_bp_sd: float = 21.0             # SD (not variance)
    reject_negative_linkers: bool = True

    # A/B domain means in kb (separate inputs; default both 12.5 kb)
    domain_mean_kb_A: float = 12.5
    domain_mean_kb_B: float = 12.5

    # How to start the alternation. None -> random start.
    # Allowed: "A", "B", or None
    start_compartment: Optional[str] = None

    # Epigenetics: compartment-specific fractions (probabilities)                                                                                                           
    ac_prob_A: float = 0.70                                                                                                                                                 
    ac_prob_B: float = 0.35                                                                                                                                                 
                                                                                                                                                                            
    h1_prob_A: float = 0.30                                                                                                                                                 
    h1_prob_B: float = 0.60                                                                                                                                                 
                                                                                                                                                                            
    # BRD4 conditional on acetylation (keep as-is)                                                                                                                          
    brd4_given_ac: float = 0.20                                                                                                                                             
                                                                                                                                                                            
    # Leading overhang (bp). Trailing overhang is chosen to fit total_bp exactly.
    leading_overhang_bp: int = 0

    # Output names
    chain_name: str = "input_chain1.txt"
    top_level_name: str = "chains.txt"
    used_settings_name: str = "settings.used.json"
    nucs_bed_name: str = "nucs.bed"

    # Optional backbone coords file (passed through to builder as `cg <path>`)
    cg_path: Optional[str] = None

    # RNG seed
    seed: int = 1


def load_settings_json(path: str) -> dict:
    """Load JSON overrides from disk."""
    with open(path, "r", encoding="utf-8") as f:
        return json.load(f)


def merge_settings(defaults: Settings, overrides: dict) -> Settings:
    """
    Merge JSON overrides into defaults, validating keys.

    Any key in overrides must match a Settings field name.
    """
    d = asdict(defaults)
    for k, v in overrides.items():
        if k not in d:
            raise KeyError(f"Unknown setting '{k}'. Allowed keys: {sorted(d.keys())}")
        d[k] = v
    return Settings(**d)


# ---------------------------
# Domain generation
# ---------------------------

def generate_domains_alternating(
    total_bp: int,
    mean_bp_A: float,
    mean_bp_B: float,
    rng: np.random.Generator,
    start: Optional[str] = None
) -> List[Tuple[str, int]]:
    """
    Generate a list of (compartment, length_bp) domains summing exactly to total_bp.

    Domains alternate A/B:
      e.g. A,B,A,B,... or B,A,B,A,...
    Domain lengths are exponential with mean depending on compartment.

    We truncate the last domain so that sum(lengths)=total_bp exactly.

    Parameters
    ----------
    total_bp:
        Total fiber length in bp.

    mean_bp_A, mean_bp_B:
        Means of exponential length distributions for A and B domains.

    start:
        If "A" or "B", force starting domain type.
        If None, choose randomly.

    Returns
    -------
    domains:
        List of (type, length_bp). Adjacent same-type domains do not occur
        (because we alternate), so no need for merging.
    """
    if start is None:
        cur = "A" if rng.random() < 0.5 else "B"
    else:
        if start not in ("A", "B"):
            raise ValueError("start_compartment must be 'A', 'B', or null/None")
        cur = start

    domains: List[Tuple[str, int]] = []
    remaining = total_bp

    while remaining > 0:
        mean = mean_bp_A if cur == "A" else mean_bp_B

        # Exponential draw; enforce at least 1 bp so we always progress
        L = int(max(1, rng.exponential(mean)))

        # Truncate last domain to fit exactly
        if L > remaining:
            L = remaining

        domains.append((cur, L))
        remaining -= L

        # Alternate compartment
        cur = "B" if cur == "A" else "A"

    return domains


def domains_to_boundaries(domains: List[Tuple[str, int]]) -> List[Tuple[int, int, str]]:
    """
    Convert (type, length) to explicit boundaries:
      [(start_bp, end_bp, type), ...] with end exclusive.
    """
    bounds = []
    pos = 0
    for t, L in domains:
        bounds.append((pos, pos + L, t))
        pos += L
    return bounds


def comp_at(bp_pos: int, boundaries: List[Tuple[int, int, str]]) -> str:
    """
    Return compartment type ("A" or "B") at bp_pos by scanning boundaries.
    """
    for a, b, t in boundaries:
        if a <= bp_pos < b:
            return t
    return boundaries[-1][2]  # fallback for edge cases


# ---------------------------
# Linker sampling & fiber layout
# ---------------------------

def build_fiber(
    total_bp: int,
    settings: Settings,
    rng: np.random.Generator
) -> Tuple[int, List[int], int, int]:
    """
    Sequentially build a 1D chromatin fiber by adding nucleosomes and sampling
    linkers one-by-one until the next (sampled linker + nucleosome) would not fit.

    Final-step rule (your requested behavior):
      - If sampled_linker + nuc_bp does not fit in remaining,
        then check if remaining >= nuc_bp.
        If yes:
          * add one final nucleosome at the end
          * set the final internal linker = remaining - nuc_bp
          * set trailing overhang = 0
        If no:
          * stop and leave trailing overhang = remaining

    Returns:
      N, linkers_bp (length N-1), lead_bp, trail_bp
    """
    nuc_bp = int(settings.nucleosomal_dna_bp)
    lead_bp = int(settings.leading_overhang_bp)

    if lead_bp < 0:
        raise ValueError("leading_overhang_bp must be >= 0")

    remaining = total_bp - lead_bp
    if remaining < nuc_bp:
        raise RuntimeError(
            f"Not enough space for one nucleosome: total_bp={total_bp}, "
            f"leading_overhang_bp={lead_bp}, nuc_bp={nuc_bp}"
        )

    # Place the first nucleosome
    N = 1
    remaining -= nuc_bp
    linkers_bp: List[int] = []

    while True:
        # Sample one linker length (bp), rejecting negatives if requested
        while True:
            x = rng.normal(loc=settings.linker_bp_mean, scale=settings.linker_bp_sd)
            if settings.reject_negative_linkers and x < 0.0:
                continue
            linker_bp = int(round(x))
            if settings.reject_negative_linkers and linker_bp < 0:
                continue
            break

        # If linker + another nucleosome fits, accept and continue
        if linker_bp + nuc_bp <= remaining:
            linkers_bp.append(linker_bp)
            remaining -= (linker_bp + nuc_bp)
            N += 1
            continue

        # Otherwise: do not accept this sampled linker.
        # Apply your "last step packing" rule:
        if remaining >= nuc_bp:
            # Add one last nucleosome at the very end.
            # The required linker is exactly what's left after reserving nucleosome DNA.
            final_linker_bp = remaining - nuc_bp  # >= 0 by condition
            linkers_bp.append(final_linker_bp)
            remaining = 0
            N += 1

        break

    trail_bp = remaining  # will be 0 if we added the final nucleosome as above
    return N, linkers_bp, lead_bp, trail_bp


def bp_to_beads(bp: int, bp_per_bead: float) -> int:
    """
    Convert basepairs to coarse-grained linker beads. Allows 0.
    Uses round() for simplicity.
    """
    if bp <= 0:
        return 0
    return int(round(bp / bp_per_bead))


def compute_nucleosome_starts_bp(
    N: int,
    linkers_bp: List[int],
    lead_bp: int,
    nuc_bp: int
) -> List[int]:
    """
    Given N, internal linkers (N-1), and leading overhang, produce nucleosome start positions (bp).

    We place nucleosome i as:
      start_0 = lead_bp
      start_{i+1} = start_i + nuc_bp + linker_bp[i]
    """
    starts = []
    pos = lead_bp
    for i in range(N):
        starts.append(pos)
        if i < N - 1:
            pos += nuc_bp + linkers_bp[i]
        else:
            pos += nuc_bp
    return starts


# ---------------------------
# State assignment (ac, brd4, H1)
# ---------------------------

def assign_states(
    nuc_starts_bp: List[int],
    boundaries: List[Tuple[int, int, str]],
    settings: Settings,
    rng: np.random.Generator
) -> Tuple[List[str], List[int], List[int], List[int]]:
    """
    Assign compartment and per-nucleosome states.

    Compartment for a nucleosome is determined by its START bp position.

    Compartment-specific probabilities from settings:
      - ac in B
      - ac in A
      - H1 in A
      - H1 in B
      - brd4 is conditional on ac: brd4_given_ac
    """
    p_ac_A = float(settings.ac_prob_A)
    p_ac_B = float(settings.ac_prob_B)
    p_h1_A = float(settings.h1_prob_A)
    p_h1_B = float(settings.h1_prob_B)

    comps: List[str] = []
    ac: List[int] = []
    brd4: List[int] = []
    h1: List[int] = []

    for s in nuc_starts_bp:
        c = comp_at(s, boundaries)
        comps.append(c)

        if c == "A":
            a = 1 if rng.random() < p_ac_A else 0
            h = 1 if rng.random() < p_h1_A else 0
        else:
            a = 1 if rng.random() < p_ac_B else 0
            h = 1 if rng.random() < p_h1_B else 0

        b = 1 if (a == 1 and rng.random() < settings.brd4_given_ac) else 0

        ac.append(a)
        brd4.append(b)
        h1.append(h)

    return comps, ac, brd4, h1


# ---------------------------
# Writers: builder files + track
# ---------------------------

def write_chain_file(
    path: str,
    N: int,
    ll_beads: List[int],
    h1: List[int],
    ac: List[int],
    brd4: List[int],
    cg_path: Optional[str] = None,
) -> None:
    """
    Write the NICG builder chain file.

    IMPORTANT:
      - ll must have length N+1
      - H1/ac/brd4 must have length N
    """
    if len(ll_beads) != N + 1:
        raise ValueError(f"ll must have length N+1={N+1}, got {len(ll_beads)}")
    if not (len(h1) == len(ac) == len(brd4) == N):
        raise ValueError("H1/ac/brd4 must all have length N")

    with open(path, "w", encoding="utf-8") as f:
        f.write(f"nuc {N}\n")
        f.write("ll " + " ".join(map(str, ll_beads)) + "\n")
        f.write("H1 " + " ".join(map(str, h1)) + "\n")
        f.write("ac " + " ".join(map(str, ac)) + "\n")
        f.write("brd4 " + " ".join(map(str, brd4)) + "\n")
        if cg_path:
            f.write(f"cg {cg_path}\n")


def write_top_level(path: str, chain_filename: str) -> None:
    """Write the top-level multi-chain file with a single chain."""
    with open(path, "w", encoding="utf-8") as f:
        f.write(f"chain {chain_filename}\n")


def write_nucs_bed(
    path: str,
    chrom: str,
    nuc_starts_bp: List[int],
    nuc_len_bp: int,
    comps: List[str],
    ac: List[int],
    brd4: List[int],
    h1: List[int],
) -> None:
    """
    Write per-nucleosome BED-like file for detailed inspection.

    Columns:
      chrom start end comp ac brd4 H1
    """
    with open(path, "w", encoding="utf-8") as f:
        f.write("#chrom\tstart\tend\tcomp\tac\tbrd4\tH1\n")
        for s, c, a, b, h in zip(nuc_starts_bp, comps, ac, brd4, h1):
            e = s + nuc_len_bp
            f.write(f"{chrom}\t{s}\t{e}\t{c}\t{a}\t{b}\t{h}\n")


# ---------------------------
# Main
# ---------------------------

def main() -> None:
    ap = argparse.ArgumentParser(
        description="Generate NICG builder inputs + nucleosome BED."
    )
    ap.add_argument("--outdir", default=".", help="Directory to write outputs.")
    ap.add_argument("--config", default=None, help="Optional JSON file overriding defaults.")
    ap.add_argument("--cg", default=None, help="Optional backbone coords path written as 'cg <path>' in chain file.")
    ap.add_argument("--seed", type=int, default=None, help="Override RNG seed.")
    args = ap.parse_args()

    # Load defaults, apply overrides if provided
    settings = Settings()
    if args.config:
        settings = merge_settings(settings, load_settings_json(args.config))
    if args.cg is not None:
        settings.cg_path = args.cg
    if args.seed is not None:
        settings.seed = args.seed

    rng = np.random.default_rng(settings.seed)

    # Total length in bp (1 kb = 1000 bp)
    total_bp = int(round(settings.total_kb * 1000.0))

    # 1) Generate 1D A/B domains that sum to total_bp
    domains = generate_domains_alternating(
        total_bp=total_bp,
        mean_bp_A=settings.domain_mean_kb_A * 1000.0,
        mean_bp_B=settings.domain_mean_kb_B * 1000.0,
        rng=rng,
        start=settings.start_compartment,
    )
    boundaries = domains_to_boundaries(domains)

    # 2) Choose N and sample internal linkers so that the full fiber fits exactly total_bp
    N, linkers_bp, lead_bp, trail_bp = build_fiber(total_bp, settings, rng)

    # 3) Compute nucleosome start positions along the 1D coordinate
    nuc_starts_bp = compute_nucleosome_starts_bp(
        N=N,
        linkers_bp=linkers_bp,
        lead_bp=lead_bp,
        nuc_bp=settings.nucleosomal_dna_bp,
    )

    # 4) Assign per-nucleosome states conditional on compartment (A/B)
    comps, ac, brd4, h1 = assign_states(nuc_starts_bp, boundaries, settings, rng)

    # 5) Convert linker bp to linker beads for the builder input
    #    Builder expects ll with N+1 integers:
    #      ll[0]     = leading overhang beads
    #      ll[1..N-1]= internal linkers between nucleosomes (N-1 values)
    #      ll[N]     = trailing overhang beads
    lead_beads = bp_to_beads(lead_bp, settings.bp_per_bead)
    trail_beads = bp_to_beads(trail_bp, settings.bp_per_bead)
    internal_beads = [bp_to_beads(x, settings.bp_per_bead) for x in linkers_bp]
    ll_beads = [lead_beads] + internal_beads + [trail_beads]

    # 6) Write outputs
    os.makedirs(args.outdir, exist_ok=True)
    chain_path = os.path.join(args.outdir, settings.chain_name)
    top_path = os.path.join(args.outdir, settings.top_level_name)
    nucs_path = os.path.join(args.outdir, settings.nucs_bed_name)
    used_path = os.path.join(args.outdir, settings.used_settings_name)

    write_chain_file(chain_path, N, ll_beads, h1, ac, brd4, cg_path=settings.cg_path)
    write_top_level(top_path, settings.chain_name)
    write_nucs_bed(
        nucs_path,
        settings.chrom_name,
        nuc_starts_bp,
        settings.nucleosomal_dna_bp,
        comps, ac, brd4, h1,
    )

    # 7) Write a reproducibility / sanity-check JSON summary
    frac_A_bp = sum(L for t, L in domains if t == "A") / total_bp
    frac_A_nucs = sum(1 for c in comps if c == "A") / max(1, N)

    # empirical rates
    ac_overall = sum(ac) / max(1, N)
    h1_overall = sum(h1) / max(1, N)
    brd4_given_ac_emp = (sum(b for b, a in zip(brd4, ac) if a == 1) / max(1, sum(ac)))

    # compartment-specific empirical rates
    nA = sum(1 for c in comps if c == "A")
    nB = N - nA
    ac_in_A = sum(a for a, c in zip(ac, comps) if c == "A") / max(1, nA)
    ac_in_B = sum(a for a, c in zip(ac, comps) if c == "B") / max(1, nB)
    h1_in_A = sum(x for x, c in zip(h1, comps) if c == "A") / max(1, nA)
    h1_in_B = sum(x for x, c in zip(h1, comps) if c == "B") / max(1, nB)

    summary = {
        "settings": asdict(settings),
        "derived": {
            "total_bp": total_bp,
            "N_nucleosomes": N,
            "leading_overhang_bp": lead_bp,
            "trailing_overhang_bp": trail_bp,
            "domains": [{"type": t, "len_bp": L} for t, L in domains],
            "fraction_A_by_bp": frac_A_bp,
            "fraction_A_by_nucleosomes": frac_A_nucs,
            "ac_frac_overall": ac_overall,
            "ac_frac_in_A": ac_in_A,
            "ac_frac_in_B": ac_in_B,
            "h1_frac_overall": h1_overall,
            "h1_frac_in_A": h1_in_A,
            "h1_frac_in_B": h1_in_B,
            "brd4_given_ac_empirical": brd4_given_ac_emp,
            "linker_bp_mean_empirical": float(np.mean(linkers_bp)) if linkers_bp else 0.0,
            "linker_bp_sd_empirical": float(np.std(linkers_bp)) if linkers_bp else 0.0,
            "ll_beads_minmax": [int(min(ll_beads)), int(max(ll_beads))],
        }
    }
    with open(used_path, "w", encoding="utf-8") as f:
        json.dump(summary, f, indent=2)

    # Console report
    print("Wrote:")
    print(f"  {top_path}")
    print(f"  {chain_path}")
    print(f"  {nucs_path}")
    print(f"  {used_path}")
    print(f"Chain summary: N={N} nucleosomes; domains={len(domains)}; frac_A_bp={frac_A_bp:.3f}; ac_overall={ac_overall:.3f}; h1_overall={h1_overall:.3f}")
    if settings.cg_path:
        print(f"Included: cg {settings.cg_path}")


if __name__ == "__main__":
    main()

